parameters:
  repository: ''
  neededArtifacts: [ ]
  artifactName: ''
  environment: ''
  dependsOn: [ ]
  targetBranch: ''
  branchName: ''
  gitUserEmail: ''
  gitUserHandle: ''
  kvName: ''
  submodules: [ ]
  upstreamRepo: ''

# execute exclusively on main branch

jobs:
  - deployment: cd_${{ parameters.environment }}
    displayName: "Push to remote ${{ parameters.repository }}"
    pool:
      vmImage: 'ubuntu-latest'
    environment: ${{ parameters.environment }}
    dependsOn: ${{ parameters.dependsOn }}
    variables:
      key: 'val'
    strategy:
      runOnce:
        deploy:
          steps:
#            - script: |
#                if [ $(Build.Reason) == "PullRequest" ]; then
#                  echo "Executed on pull request from $(System.PullRequest.SourceBranch)"
#                  exit 1
#                fi
#              displayName: "Verify non pull request build reason"

            - script: |
                sudo apt-key adv --keyserver keyserver.ubuntu.com --recv-key C99B11DEB97541F0
                sudo apt-add-repository https://cli.github.com/packages
                sudo apt update
                sudo apt install gh
                gh --version
              displayName: 'Install gh'

            - task: AzureCLI@2
              displayName: "Environment: add secrets"
              inputs:
                azureSubscription: "AzureDevTest-EA"
                scriptType: pscore
                scriptLocation: inlineScript
                inlineScript: |
                  Write-Output "Retrieving secrets from ${{ parameters.kvName }}"
                  $secretList = (az keyvault secret list --vault-name ${{ parameters.kvName }} | ConvertFrom-Json)
                  $secrets = $secretList | ForEach-Object  { "export $(($_.name -creplace '(?<!^)\p{Lu}', '_$&').ToUpper())=$(((az keyvault secret show --id $($_.id)) | ConvertFrom-Json).value )" }

                  Write-Output "Secrets extracted:"
                  $secretList | ForEach-Object { "$($_.name)" }
                  $secretList = ""

                  if  ($secrets) {
                    $secrets > $(Pipeline.Workspace)/secrets.env
                  }
                  else {
                    Write-Error "No secrets retrieved. Halting execution!"
                    Exit1
                  }

                  Write-Output "Cleaning up secrets..."
                  $secrets = ""
                  Write-Output "All done!"

            - script: |
                export $(cat $(Pipeline.Workspace)/secrets.env | xargs)
                export TMP_TOKEN=$GITHUB_TOKEN
                unset GITHUB_TOKEN
                gh auth login --hostname github.com --with-token <<< $TMP_TOKEN
                gh auth status 2>&1 | grep "Logged in to github.com" || exit 1
                git config -l --show-origin
              workingDirectory: $(Agent.BuildDirectory)
              displayName: 'gh login'

            # checkout target repository to $(Agent.BuildDirectory)
            - checkout: ${{ parameters.repository }}
              submodules: recursive
              displayName: 'checkout ${{ parameters.repository }}'
              path: remote
              persistCredentials: 'true'

            - script: |
                set -ex
                git status
                remote_url=$(git config --get-all remote.origin.url)
                echo $remote_url
                extra_header=$(git config --get-all http.$remote_url.extraheader)
                echo $extra_header
                git remote add upstream ${{ parameters.upstreamRepo }}
                upstream_url=$(git config --get-all remote.upstream.url)
                git config http.$upstream_url.extraheader "$extra_header"
                git remote update
                git fetch
                git checkout --track upstream/${{ parameters.targetBranch }}
                git status
              displayName: 'Update branch from upstream'
              workingDirectory: '$(Agent.BuildDirectory)/remote'

            # checkout self to $(Agent.BuildDirectory)/self
            - checkout: self
              submodules: recursive
              displayName: 'checkout self'
              path: self
              persistCredentials: 'true'

            # download build artifact to $(Pipeline.Workspace)
            - ${{ each artifact in parameters.neededArtifacts }}:
                - download: current
                  artifact: ${{ artifact }}
                  displayName: Download ${{ artifact }}

            - script: |
                set -ex
                git status
                git remote update
                git fetch
                set +e
                #verify that the target branch exists
                git rev-parse --verify origin/${{ parameters.branchName }}
                CHECK_BRANCH=$?
                set -e
                if [[  $CHECK_BRANCH -eq 0 ]];then
                  echo "Branch origin/${{ parameters.branchName }} exists already"
                fi
                git checkout -b ${{ parameters.branchName }}
                git push origin ${{ parameters.branchName }} --force

                git rm -rf .
                git config --global user.email ${{ parameters.gitUserEmail }}
                git config --global user.name ${{ parameters.gitUserHandle }}
                git status
              displayName: 'Checkout ${{ parameters.branchName }}'
              workingDirectory: '$(Agent.BuildDirectory)/remote'

            - script: |
                set -x
                rm -rf ./remote/*
                cp -r ./${{ parameters.artifactName }}/. ./remote
                touch ./remote/.gitmodules
                ls ./remote
              displayName: 'Apply changes to git repo'
              workingDirectory: '$(Agent.BuildDirectory)'

            - ${{ each submodule in parameters.submodules }}:
              - script: |
                  set -x
                  cd $(Agent.BuildDirectory)/self
                  git submodule status
                  doc_commit_id=$(git submodule status | grep ${{ submodule.name }} | cut -f 2 -d " ")
                  cd $(Agent.BuildDirectory)/remote
                  git rm --cached -r ./${{ submodule.name }} --force
                  rm -rf ./${{ submodule.name }}
                  git submodule status
                  ls ./${{ submodule.targetName }}
                  git status
                  git submodule add --force ${{ submodule.repo }} ${{ submodule.name }}
                  git submodule status
                  cd ${{ submodule.name }}
                  git checkout $doc_commit_id
                  cd ..
                  git submodule status
                  git status
                displayName: 'add submodule '
                workingDirectory: '$(Agent.BuildDirectory)/remote'

            - script: |
                set -x
                git add .
                git commit -a -m "Update"
                git push --set-upstream origin ${{ parameters.branchName }} --force
                git status
              displayName: 'Commit changes'
              workingDirectory: '$(Agent.BuildDirectory)/remote'
